package com.blisek.compiler_jftt.parser;

import com.blisek.compiler_jftt.ast.*;
import java.util.List;
import com.blisek.compiler_jftt.structs.*;
import java.math.BigInteger;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.grammar".
 */
public class ExpressionParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short SEMIC = 1;
		static public final short PIDENTIFIER = 2;
		static public final short NUMBER = 3;
		static public final short ZERO = 4;
		static public final short ONE = 5;
		static public final short RBRACKET = 6;
		static public final short PLUS = 7;
		static public final short MINUS = 8;
		static public final short MULT = 9;
		static public final short MOD = 10;
		static public final short LBRACKET = 11;
		static public final short READ = 12;
		static public final short WRITE = 13;
		static public final short SKIP = 14;
		static public final short DIV = 15;
		static public final short VAR = 16;
		static public final short BEGIN = 17;
		static public final short END = 18;
		static public final short ASSIGN = 19;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orrDbF4r4K1l2lKmeMB2gsfRGK4LmGGS22gAY8gAXrUU211n9vqCGO7umlxblSzttVufl" +
		"$Z$k#xwAuxthyvlRKD6EDcEYT$EQxT#umS#UK6G1da8UUwCjzBsHZ2Cen51Meb7UOW4cOWZ" +
		"ZdV2X050FPwuDX68N#EjS36SX29gfGWnZgpNmkUgFEzC8eD5c4VYPBK6fo40PZDCPW7CRp2" +
		"XQcoLbua8y0rn2XOXf0PURiF5Hh3jUirHoXELApGNEiPgDca#Pak4NWHOvqoNFfX1$DybGU" +
		"oqC44P87Sa$ko6svAJVakboJo$9MtiXhUIKlvOKyaVjoIwxACtaaT#KAm6jEH0kcmcupa6Z" +
		"JCPDN3V2Px7q1An1X3QAiW8irzh4s5hSiFhMNjRRWPlqyh7jYpizL1hdEN#UJlTzbyY$yh7" +
		"sGrGwP6NiDgPB7$bNccoguTClXiKGlavlhRpR#AbQonxvRJECLCtc7MMiJjQtIz6cjSscn7" +
		"fjhLW8iqN4sbT9IMaRBxUCwjuYQQ8MELsgMqIfQJMkeWjRHUjf0rRIHDj5cggKjj9MsqNRQ" +
		"GJjf5#scCCLfZ$qSj9TQQH#rqNvgfmCKemuwI7Fe4CsZmxI0Zj1HEgxhNKWdj7yovVcEqIa" +
		"wdNAiX6PhlvoyoJaRIztf67UbZl#4hSOnZZd6TOvnVJUlsw3PgDcisQ8PJpat#N$IgjccsQ" +
		"uvF#NSZcxUt$xD85#XJRveViBF9fVaebmmlVDq3l#boKUp$q3lvRDyDwDlt5NoRRU$dHPvp" +
		"1jfl$iXlaj1VXc2V5CJB7wDN6c5EUyKIQCmZQX3KHe1tiFcDpACuX##xCo3");

	private final Action[] actions;

	public ExpressionParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = VAR vdeclarations.v BEGIN commands.c END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 2];
					final VDeclarationsExpression v = (VDeclarationsExpression) _symbol_v.value;
					final Symbol _symbol_c = _symbols[offset + 4];
					final Expression c = (Expression) _symbol_c.value;
					 return new ProgramExpression(c, v);
				}
			},
			new Action() {	// [1] vdeclarations = vdeclarations.v PIDENTIFIER.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final VDeclarationsExpression v = (VDeclarationsExpression) _symbol_v.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final String p = (String) _symbol_p.value;
					 VDeclaration vd = VDeclaration.of(p); 
						return VDeclarationHelper.extendOrMakeListOfVDec(vd, v);
				}
			},
			new Action() {	// [2] vdeclarations = vdeclarations.v PIDENTIFIER.p LBRACKET NUMBER.n RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final VDeclarationsExpression v = (VDeclarationsExpression) _symbol_v.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final String p = (String) _symbol_p.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final BigInteger n = (BigInteger) _symbol_n.value;
					 
						VDeclaration vd = VDeclaration.arrayOf(p, n); 
						return VDeclarationHelper.extendOrMakeListOfVDec(vd, v);
				}
			},
			new Action() {	// [3] vdeclarations = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new VDeclarationsExpression();
				}
			},
			new Action() {	// [4] commands = commands.s command.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Expression s = (Expression) _symbol_s.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final Expression c = (Expression) _symbol_c.value;
					 return new Expression(s, c);
				}
			},
			new Action() {	// [5] commands = command.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expression c = (Expression) _symbol_c.value;
					 return c;
				}
			},
			new Action() {	// [6] command = identifier.i ASSIGN expression.e SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final ValueExpression i = (ValueExpression) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new AssignmentExpression(i, e);
				}
			},
			new Action() {	// [7] command = READ identifier.i SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final ValueExpression i = (ValueExpression) _symbol_i.value;
					 return new ReadExpression(i);
				}
			},
			new Action() {	// [8] command = WRITE value.v SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 2];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return new WriteExpression(v);
				}
			},
			new Action() {	// [9] command = SKIP SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new SkipExpression();
				}
			},
			Action.RETURN,	// [10] expression = value
			Action.RETURN,	// [11] expression = addition
			Action.RETURN,	// [12] expression = subtraction
			Action.RETURN,	// [13] expression = multiplication
			Action.RETURN,	// [14] expression = division
			Action.RETURN,	// [15] expression = modulo
			new Action() {	// [16] addition = value.v PLUS ZERO
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [17] addition = ZERO PLUS value.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 3];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [18] addition = value.v1 PLUS value.v2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v1 = _symbols[offset + 1];
					final ValueExpression v1 = (ValueExpression) _symbol_v1.value;
					final Symbol _symbol_v2 = _symbols[offset + 3];
					final ValueExpression v2 = (ValueExpression) _symbol_v2.value;
					 return new AdditionExpression(v1, v2);
				}
			},
			new Action() {	// [19] addition = value.v1 PLUS ONE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v1 = _symbols[offset + 1];
					final ValueExpression v1 = (ValueExpression) _symbol_v1.value;
					 return new AdditionExpression(new NumberValueExpression(BigInteger.ONE), v1);
				}
			},
			new Action() {	// [20] addition = ONE PLUS value.v2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v2 = _symbols[offset + 3];
					final ValueExpression v2 = (ValueExpression) _symbol_v2.value;
					 return new AdditionExpression(new NumberValueExpression(BigInteger.ONE), v2);
				}
			},
			new Action() {	// [21] subtraction = value.v MINUS ZERO
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [22] subtraction = ZERO MINUS value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [23] subtraction = value.v1 MINUS value.v2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v1 = _symbols[offset + 1];
					final ValueExpression v1 = (ValueExpression) _symbol_v1.value;
					final Symbol _symbol_v2 = _symbols[offset + 3];
					final ValueExpression v2 = (ValueExpression) _symbol_v2.value;
					 return new SubtractionExpression(v1, v2);
				}
			},
			new Action() {	// [24] subtraction = ONE MINUS value.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 3];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return new SubtractionExpression(new NumberValueExpression(BigInteger.ONE), v);
				}
			},
			new Action() {	// [25] subtraction = value.v MINUS ONE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return new SubtractionExpression(v, new NumberValueExpression(BigInteger.ONE));
				}
			},
			new Action() {	// [26] multiplication = value MULT ZERO
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [27] multiplication = ZERO MULT value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [28] multiplication = value.v MULT ONE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [29] multiplication = ONE MULT value.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 3];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [30] multiplication = value.v1 MULT value.v2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v1 = _symbols[offset + 1];
					final ValueExpression v1 = (ValueExpression) _symbol_v1.value;
					final Symbol _symbol_v2 = _symbols[offset + 3];
					final ValueExpression v2 = (ValueExpression) _symbol_v2.value;
					 return new MultiplyExpression(v1, v2);
				}
			},
			new Action() {	// [31] division = value DIV ZERO
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [32] division = ZERO DIV value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [33] division = value.v DIV ONE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ValueExpression v = (ValueExpression) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [34] division = value.v1 DIV value.v2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v1 = _symbols[offset + 1];
					final ValueExpression v1 = (ValueExpression) _symbol_v1.value;
					final Symbol _symbol_v2 = _symbols[offset + 3];
					final ValueExpression v2 = (ValueExpression) _symbol_v2.value;
					 return new DivisionExpression(v1, v2);
				}
			},
			new Action() {	// [35] modulo = value MOD ZERO
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [36] modulo = value MOD ONE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [37] modulo = ZERO MOD value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ZERO);
				}
			},
			new Action() {	// [38] modulo = ONE MOD value
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NumberValueExpression(BigInteger.ONE);
				}
			},
			new Action() {	// [39] modulo = value.v1 MOD value.v2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v1 = _symbols[offset + 1];
					final ValueExpression v1 = (ValueExpression) _symbol_v1.value;
					final Symbol _symbol_v2 = _symbols[offset + 3];
					final ValueExpression v2 = (ValueExpression) _symbol_v2.value;
					 return new ModuloExpression(v1, v2);
				}
			},
			new Action() {	// [40] value = NUMBER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final BigInteger n = (BigInteger) _symbol_n.value;
					 return new NumberValueExpression(n);
				}
			},
			Action.RETURN,	// [41] value = identifier
			new Action() {	// [42] identifier = PIDENTIFIER.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					 return new VariableValueExpression(VariableInfo.of(p));
				}
			},
			new Action() {	// [43] identifier = PIDENTIFIER.p LBRACKET NUMBER.n RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final BigInteger n = (BigInteger) _symbol_n.value;
					 return new ArrayValueExpression(VariableInfo.of(p), n);
				}
			},
			new Action() {	// [44] identifier = PIDENTIFIER.p1 LBRACKET PIDENTIFIER.p2 RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p1 = _symbols[offset + 1];
					final String p1 = (String) _symbol_p1.value;
					final Symbol _symbol_p2 = _symbols[offset + 3];
					final String p2 = (String) _symbol_p2.value;
					 return new ArrayVariableValueExpression(VariableInfo.of(p1), p2);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
