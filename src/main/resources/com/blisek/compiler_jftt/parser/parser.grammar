%package "com.blisek.compiler_jftt.parser";
%import "com.blisek.compiler_jftt.ast.*";
%import "com.blisek.compiler_jftt.structs.*";
%import "java.math.BigInteger";
%class "ExpressionParser";

%terminals NUMBER, ZERO, ONE, SEMIC, VAR, BEGIN, EOF, PIDENTIFIER;
%terminals END, MULT, DIV, PLUS, MINUS, MOD;
%terminals IF, THEN, ELSE, ENDIF, WHILE, DO, ENDWHILE;
%terminals FOR, FROM, TO, DOWNTO, ENDFOR, READ, WRITE, SKIP;
%terminals LBRACKET, RBRACKET, ASSIGN;
%terminals EQ, NEQ, LT, GT, LE, GE;

%left  MULT, DIV, MOD;
%left  PLUS, MINUS;

%typeof NUMBER = "BigInteger";
%typeof PIDENTIFIER = "String";
%typeof program, commands, command, expression = "Expression";
%typeof addition = "Expression";
%typeof subtraction = "Expression";
%typeof multiplication = "Expression";
%typeof division = "Expression";
%typeof modulo = "Expression";
%typeof value, identifier = "ValueExpression";

%goal program;


program       
					= BEGIN commands.c END	{: return new ProgramExpression(c); :} 
					;

commands    
					= commands.s command.c	{: return new Expression(s, c); :}
             		| command.c				{: return c; :} 
             		;

command     
					= identifier.i ASSIGN expression.e SEMIC {: return new AssignmentExpression(i, e); :}
             		| READ identifier.i SEMIC {: return new ReadExpression(i); :}
             		| WRITE value.v SEMIC {: return new WriteExpression(v); :}
             		| SKIP SEMIC {: return new SkipExpression(); :}
             		;

expression  		
					= value
             		| addition
             		| subtraction
             		| multiplication
             		| division
             		| modulo
             		;
             		
addition
					= value.v PLUS ZERO			{: return v; :}
					| ZERO PLUS value.v			{: return v; :}
					| value.v1 PLUS value.v2	{: return new AdditionExpression(v1, v2); :}
					;

subtraction
					= value.v MINUS ZERO		{: return v; :}
					| ZERO MINUS value			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| value.v1 MINUS value.v2	{: return new SubtractionExpression(v1, v2); :}
					;

multiplication
					= value MULT ZERO			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| ZERO MULT value			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| value.v MULT ONE			{: return v; :}
					| ONE MULT value.v			{: return v; :} 
					| value.v1 MULT value.v2	{: return new MultiplyExpression(v1, v2); :}
					;
					
division
					= value DIV ZERO			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| ZERO DIV value			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| value.v DIV ONE			{: return v; :}
					| value.v1 DIV value.v2		{: return new DivisionExpression(v1, v2); :}
					; 
				
modulo
					= value MOD ZERO			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| value.v MOD ONE			{: return v; :} 
					| ZERO MOD value			{: return new NumberValueExpression(BigInteger.ZERO); :}
					| ONE MOD value				{: return new NumberValueExpression(BigInteger.ONE); :}
					| value.v1 MOD value.v2		{: return new ModuloExpression(v1, v2); :}
					;

value       
					= NUMBER.n					{: return new NumberValueExpression(n); :}
             		| identifier
             		;

identifier  
					= PIDENTIFIER.p 			{: return new VariableValueExpression(new VariableInfo(p)); :}
             		;

    